通过实验体会MVC模式的, 观察MVC模式下各部分之间的交互关系, 体会MVC模式下各部分之间的解耦合, 体会MVC模式下各部分之间的独立性, 体会MVC模式下各部分之间的复用性, 体会MVC模式下各部分之间的可扩展性, 体会MVC模式下各部分之间的灵活性,
体会MVC模式下各部分之间的强关联与弱关联.练习Button,TextView,ScrowView等组件还有线性布局的约束.
开始界面 : 两个Button组件,一个TextView组件,线性布局
控制层界面: findViewById取出上面三个组件, 并设置点击事件,当用户点击yes按钮跳转到答题界面,点击no按钮跳则finish当前活动直接退出
问题显示栏显示问题数组的内容.
输入栏采用EditText组件,并设置输入监听,当用户输入内容后,调用控制层的方法,将用户输入的内容传递给控制层.
锁定输入栏采用ToggleButton组件,当用户点击锁定按钮时,调用控制层的方法,将锁定状态传递给控制层.输入栏将不可用,再次点击可以释放锁定
问题提示组件采用Button组件,点击,输入栏显示hint提示,提示内容从答案数组获取
PRE和NEXT按钮采用Button组件,点击,调用控制层的方法,根据index参数的变化刷新问题显示栏和输入栏的内容.
submit按钮是提交prompt,wrong,right数组还有score分数到活动3
活动2的信息将加载活动3的界面上,prompt,wrong,right数组的内容采用ScrowView组件显示.
QUIT按钮直接退出当前活动,RESTART按钮回到活动2答题
create->start->resume
活动1跳转到活动2,但是活动1并没有销毁.只是活动2盖住了活动1的呈现,活动1依旧在后台
活动2跳转到活动3,首先活动1先被销毁.
活动3再被创建加载完成后销毁活动2.但其实是活动2将活动栈自身上方的销毁,活动1才会被销毁,活动2也销毁了自身.
点击RESTART,创建活动2,然后活动3才挂起
若点击quit,则销毁活动3,直接退出,因为活动栈只剩一个活动3
分析活动各阶段的生命周期,并理解活动各阶段的生命周期方法什么时候被调用.横竖屏的切换
横竖屏的切换实际上是创建一个新的Activity
设置layout-land和layout-port两个文件夹,分别存放横屏和竖屏资源
重写方法,在活动销毁前将数据保存,然后活动创建再将数据赋值回去.当然onDestory生命周期将数据保存,onCreate时将数据赋值也行
,也可以设置静态变量来做,